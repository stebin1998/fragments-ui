import { Fetcher } from "./https.js";
import { JwtHeader, JwtPayload } from "./jwt-model.js";
import { Json, JsonObject } from "./safe-json-parse.js";
interface DecomposedJwt {
    header: JwtHeader;
    payload: JwtPayload;
}
declare const optionalJwkFieldNames: readonly ["use", "alg", "kid", "n", "e", "x", "y", "crv"];
declare const mandatoryJwkFieldNames: readonly ["kty"];
type OptionalJwkFieldNames = (typeof optionalJwkFieldNames)[number];
type MandatoryJwkFieldNames = (typeof mandatoryJwkFieldNames)[number];
type OptionalJwkFields = {
    [key in OptionalJwkFieldNames]?: string;
};
type MandatoryJwkFields = {
    [key in MandatoryJwkFieldNames]: string;
};
export type Jwk = OptionalJwkFields & MandatoryJwkFields & JsonObject;
type RsaSignatureJwk = Jwk & {
    use?: "sig";
    kty: "RSA";
    n: string;
    e: string;
};
type EcSignatureJwk = Jwk & {
    use?: "sig";
    kty: "EC";
    crv: "P-256" | "P-384" | "P-521";
    x: string;
    y: string;
};
type OkpSignatureJwk = Jwk & {
    use?: "sig";
    /**
     * Octet Key Pair: https://www.rfc-editor.org/rfc/rfc8037.html#section-2
     */
    kty: "OKP";
    /**
     * Edwards-curves, for EdDSA: https://www.rfc-editor.org/rfc/rfc8037.html#section-3.1
     */
    crv: "Ed25519" | "Ed448";
    x: string;
};
export type SignatureJwk = RsaSignatureJwk | EcSignatureJwk | OkpSignatureJwk;
export type JwkWithKid = Jwk & {
    kid: string;
};
export declare function findJwkInJwks(jwks: Jwks, kid: string): JwkWithKid | undefined;
interface JwksFields {
    keys: readonly Jwk[];
}
export type Jwks = JwksFields & JsonObject;
export interface JwksCache {
    getJwk(jwksUri: string, decomposedJwt: DecomposedJwt): Promise<JwkWithKid>;
    getCachedJwk(jwksUri: string, decomposedJwt: DecomposedJwt): JwkWithKid;
    addJwks(jwksUri: string, jwks: Jwks): void;
    getJwks(jwksUri: string): Promise<Jwks>;
}
/**
 * UTF-8 decode binary data and then JSON parse it, and ensure it is a JWKS
 * @param jwksBin
 * @returns Jwks
 */
export type JwksParser = (jwksBin: ArrayBuffer) => Jwks;
export declare function fetchJwks(jwksUri: string): Promise<Jwks>;
export declare function fetchJwk(jwksUri: string, decomposedJwt: DecomposedJwt): Promise<JwkWithKid>;
export declare function assertIsJwks(jwks: Json): asserts jwks is Jwks;
export declare function assertIsSignatureJwk(jwk: Jwk): asserts jwk is SignatureJwk;
export declare function assertIsJwk(jwk: Json): asserts jwk is Jwk;
export declare function isJwks(jwks: Json): jwks is Jwks;
export declare function isJwk(jwk: Json): jwk is Jwk;
export interface PenaltyBox {
    wait: (jwksUri: string, kid: string) => Promise<void>;
    registerFailedAttempt: (jwksUri: string, kid: string) => void;
    registerSuccessfulAttempt: (jwksUri: string, kid: string) => void;
}
export declare class SimplePenaltyBox implements PenaltyBox {
    waitSeconds: number;
    private waitingUris;
    constructor(props?: {
        waitSeconds?: number;
    });
    wait(jwksUri: string): Promise<void>;
    release(jwksUri: string): void;
    registerFailedAttempt(jwksUri: string): void;
    registerSuccessfulAttempt(jwksUri: string): void;
}
export declare class SimpleJwksCache implements JwksCache {
    fetcher: Fetcher;
    penaltyBox: PenaltyBox;
    jwksParser: JwksParser;
    private jwksCache;
    private fetchingJwks;
    constructor(props?: {
        penaltyBox?: PenaltyBox;
        fetcher?: Fetcher;
        jwksParser?: JwksParser;
    });
    /**
     * Add a JWKS to the cache explicitly. E.g. you may want to do this, if you have already downloaded the JWKS.
     *
     * @param jwksUri - The URI where your IDP exposes the JWKS, e.g. `https://example.com/my-idp/.well-known/jwks.json` (this is used as cache key)
     * @param jwks - The JWKS
     */
    addJwks(jwksUri: string, jwks: Jwks): void;
    /**
     * Fetch and cache the JWKS from the jwksUri
     *
     * @param jwksUri - The URI where your IDP exposes the JWKS, e.g. `https://example.com/my-idp/.well-known/jwks.json`
     * @returns - The fetched jwks
     */
    getJwks(jwksUri: string): Promise<Jwks>;
    /**
     * Get the JWKS from the cache (synchronously). Raises an error if the JWKS is not yet cached, or does not have the right JWK.
     *
     * @param jwksUri - The URI where your IDP exposes the JWKS, e.g. `https://example.com/my-idp/.well-known/jwks.json` (this is used as cache key)
     * @param decomposedJwt - The decomposed JWT
     * @returns - The previously cached JWKS
     */
    getCachedJwk(jwksUri: string, decomposedJwt: DecomposedJwt): JwkWithKid;
    /**
     * Get the right JWK to verify the JWT with. This will fetch (and cache) the JWKS in case it's not yet been cached,
     * or if the cached JWKS doesn't have the right JWK (to account for key rotations, based on `kid`).
     *
     * @param jwksUri
     * @param decomposedJwt
     * @returns  - The JWK
     */
    getJwk(jwksUri: string, decomposedJwt: DecomposedJwt): Promise<JwkWithKid>;
}
export {};
