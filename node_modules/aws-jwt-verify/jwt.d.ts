import { JwtHeader, JwtPayload } from "./jwt-model.js";
import { AsAsync } from "./typing-util.js";
/**
 * Type for a generic key object, at runtime either the Node.js or WebCrypto concrete key object is used
 */
export type GenericKeyObject = Object;
/**
 * Verify (synchronously) the JSON Web Signature (JWS) of a JWT
 * https://datatracker.ietf.org/doc/html/rfc7515
 *
 * @param keyObject: the keyobject (representing the public key) in native crypto format
 * @param alg: the JWS algorithm that was used to create the JWS (e.g. RS256)
 * @param jwsSigningInput: the input for which the JWS was created, i.e. that what was signed
 * @param signature: the JSON Web Signature (JWS)
 * @returns boolean: true if the JWS is valid, or false otherwise
 */
export type JwsVerificationFunctionSync<T extends string> = (props: {
    keyObject: GenericKeyObject;
    alg: T;
    jwsSigningInput: string;
    signature: string;
}) => boolean;
/**
 * Verify (asynchronously) the JSON Web Signature (JWS) of a JWT
 * https://datatracker.ietf.org/doc/html/rfc7515
 *
 * @param keyObject: the keyobject (representing the public key) in native crypto format
 * @param alg: the JWS algorithm that was used to create the JWS (e.g. RS256)
 * @param jwsSigningInput: the input for which the JWS was created, i.e. that what was signed
 * @param signature: the JSON Web Signature (JWS)
 * @returns Promise that resolves to a boolean: true if the JWS is valid, or false otherwise
 */
export type JwsVerificationFunctionAsync<T extends string> = AsAsync<JwsVerificationFunctionSync<T>>;
/**
 * Sanity check, decompose and JSON parse a JWT string into its constituent, and yet unverified, parts:
 * - header object
 * - payload object
 * - signature string
 *
 * This function does NOT verify a JWT, do not trust the returned payload and header!
 *
 * For most use cases, you would not want to call this function directly yourself, rather you
 * would call verify() with the JWT, which would call this function (and others) for you.
 *
 * @param jwt The JWT (as string)
 * @returns the decomposed, and yet unverified, JWT
 */
export declare function decomposeUnverifiedJwt(jwt: unknown): DecomposedJwt;
export interface DecomposedJwt {
    /**
     * The yet unverified (!) header of the JWT
     */
    header: JwtHeader;
    /**
     * The yet unverified (!) header of the JWT, as base64url-encoded string
     */
    headerB64: string;
    /**
     * The yet unverified (!) payload of the JWT
     */
    payload: JwtPayload;
    /**
     * The yet unverified (!) payload of the JWT, as base64url-encoded string
     */
    payloadB64: string;
    /**
     * The yet unverified (!) signature of the JWT, as base64url-encoded string
     */
    signatureB64: string;
}
/**
 * Validate JWT payload fields. Throws an error in case there's any validation issue.
 *
 * @param payload The (JSON parsed) JWT payload
 * @param options The options to use during validation
 * @returns void
 */
export declare function validateJwtFields(payload: JwtPayload, options: {
    issuer?: string | string[] | null;
    audience?: string | string[] | null;
    scope?: string | string[] | null;
    graceSeconds?: number;
}): void;
